///////////////////////////////////////////////////////////////////////////////////
// Standard C library functions
///////////////////////////////////////////////////////////////////////////////////

#include "libc.h"
#include "process.h"
#include "display.h"

extern process *current_process;

char *strcpy(char *dest, const char *src) {
    char *save = dest;
    while(*dest++ = *src++);
    return save;	
}

int strcmp(const char *s1, const char *s2)
{
    for ( ; *s1 == *s2; s1++, s2++)
  	if (*s1 == '\0') return 0;
    return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1);
}

int strlen(const char *s) {
    const char *p = s;
    while (*s) ++s;
    return s - p;
}

int strncmp(const char *s1, const char *s2, uint n)
{
    for ( ; n > 0; s1++, s2++, --n)
    if (*s1 != *s2)
        return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1);
    else if (*s1 == '\0')
        return 0;
    return 0;
}

// Copy len bytes from src to dest.
void memcpy(void *dest, const void *src, uint len)
{
    const u8int *sp = (const u8int *)src;
    u8int *dp = (u8int *)dest;
    for(; len != 0; len--) *dp++ = *sp++;
}

// Write len copies of val into dest.
void memset(void *dest, u8int val, uint len)
{
    u8int *temp = (u8int *)dest;
    for ( ; len != 0; len--) *temp++ = val;
}

void getch() {
    current_process->buffer = 0;
    while (!current_process->buffer);
}

///////////////////////////////////////////////////////////////////////////////////
// Debug functions
///////////////////////////////////////////////////////////////////////////////////
extern process processes[3];

void debug_i(char *msg, uint nb) {
    puts(&current_process->disp, msg);
    puti(&current_process->disp, nb);
    putcr(&current_process->disp);
}

void debug(char *msg) {
    puts(&current_process->disp, msg);
}

// Prints the stack trace. This is called by stack_dump() defined in
// kernel_entry.asm which determines the ESP and EBP pointers
// This function goes through the stack and finds the address of the
// EIP pointers for each function call
// You can find what function those pointers correspond to by looking at kernel.map
// which is generated by the makefile
void C_stack_dump(void *esp, void *ebp) {
    debug_i("ESP: ", (uint)esp);
    debug_i("EBP: ", (uint)ebp);
//    dump_mem(esp, 320, 1);
    uint ptr = (uint)esp;
    uint stack_start = (uint)&current_process->stack;
    uint stack_end = (uint)&current_process->stack + PROCESS_STACK_SIZE;
    uint fct_ptr, nb_lines, zeros;
    u8int *code_ptr;

    while (ptr >= stack_start && ptr <= stack_end) {
        fct_ptr = *((uint*)ptr + 1);
        code_ptr = (u8int*)fct_ptr;

        debug_i("Stack: ", fct_ptr);
        ptr = (uint)(*(uint*)ptr);
    }
}

void dump_mem(void *ptr, int nb_bytes, int row) {
    unsigned char *addr = (unsigned char *)ptr;

    int offset = (uint)addr % 16;
    int i, j;

    print_ptr(addr - offset, row, 0);
    print("                                                  ", row, 10, YELLOW_ON_BLACK);
    for (i=0; i< 16-offset; i++) print_hex2(*addr++, row, offset * 3 + 12 + i*3);

    int nb_rows = (nb_bytes - 16 + offset) / 16 + 1;
    for (j=0; j<nb_rows; j++) {
        print_ptr(addr - 0, ++row, 0);
        print("                                                  ", row, 10, YELLOW_ON_BLACK);
        for (i=0; i<16; i++) print_hex2(*addr++, row, 12 + i*3);
    }
}
